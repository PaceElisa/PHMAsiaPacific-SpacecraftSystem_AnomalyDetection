function [featureTable,ranking,outputTable] = diagnosticFeatures(inputData)
%DIAGNOSTICFEATURES recreates results in Diagnostic Feature Designer.
%
% Input:
%  inputData: A table or a cell array of tables/matrices containing the
%  data as those imported into the app.
%
% Output:
%  featureTable: A table containing all features and condition variables.
%  ranking: A table containing ranking scores for selected features.
%  outputTable: A table containing the computation results.
%
% This function computes spectra:
%  Case_ps/SpectrumData
%  Case_ps_1/SpectrumData
%  Case_ps_2/SpectrumData
%  Case_ps_3/SpectrumData
%  Case_ps_4/SpectrumData
%  Case_ps_5/SpectrumData
%  Case_ps_6/SpectrumData
%
% This function computes features:
%  Case_sigstats/ClearanceFactor
%  Case_sigstats/CrestFactor
%  Case_sigstats/ImpulseFactor
%  Case_sigstats/Kurtosis
%  Case_sigstats/Mean
%  Case_sigstats/PeakValue
%  Case_sigstats/RMS
%  Case_sigstats/SINAD
%  Case_sigstats/SNR
%  Case_sigstats/ShapeFactor
%  Case_sigstats/Skewness
%  Case_sigstats/Std
%  Case_sigstats/THD
%  Case_sigstats_1/ClearanceFactor
%  Case_sigstats_1/CrestFactor
%  Case_sigstats_1/ImpulseFactor
%  Case_sigstats_1/Kurtosis
%  Case_sigstats_1/Mean
%  Case_sigstats_1/PeakValue
%  Case_sigstats_1/RMS
%  Case_sigstats_1/SINAD
%  Case_sigstats_1/SNR
%  Case_sigstats_1/ShapeFactor
%  Case_sigstats_1/Skewness
%  Case_sigstats_1/Std
%  Case_sigstats_1/THD
%  Case_sigstats_2/ClearanceFactor
%  Case_sigstats_2/CrestFactor
%  Case_sigstats_2/ImpulseFactor
%  Case_sigstats_2/Kurtosis
%  Case_sigstats_2/Mean
%  Case_sigstats_2/PeakValue
%  Case_sigstats_2/RMS
%  Case_sigstats_2/SINAD
%  Case_sigstats_2/SNR
%  Case_sigstats_2/ShapeFactor
%  Case_sigstats_2/Skewness
%  Case_sigstats_2/Std
%  Case_sigstats_2/THD
%  Case_sigstats_3/ClearanceFactor
%  Case_sigstats_3/CrestFactor
%  Case_sigstats_3/ImpulseFactor
%  Case_sigstats_3/Kurtosis
%  Case_sigstats_3/Mean
%  Case_sigstats_3/PeakValue
%  Case_sigstats_3/RMS
%  Case_sigstats_3/SINAD
%  Case_sigstats_3/SNR
%  Case_sigstats_3/ShapeFactor
%  Case_sigstats_3/Skewness
%  Case_sigstats_3/Std
%  Case_sigstats_3/THD
%  Case_sigstats_4/ClearanceFactor
%  Case_sigstats_4/CrestFactor
%  Case_sigstats_4/ImpulseFactor
%  Case_sigstats_4/Kurtosis
%  Case_sigstats_4/Mean
%  Case_sigstats_4/PeakValue
%  Case_sigstats_4/RMS
%  Case_sigstats_4/SINAD
%  Case_sigstats_4/SNR
%  Case_sigstats_4/ShapeFactor
%  Case_sigstats_4/Skewness
%  Case_sigstats_4/Std
%  Case_sigstats_4/THD
%  Case_sigstats_5/ClearanceFactor
%  Case_sigstats_5/CrestFactor
%  Case_sigstats_5/ImpulseFactor
%  Case_sigstats_5/Kurtosis
%  Case_sigstats_5/Mean
%  Case_sigstats_5/PeakValue
%  Case_sigstats_5/RMS
%  Case_sigstats_5/SINAD
%  Case_sigstats_5/SNR
%  Case_sigstats_5/ShapeFactor
%  Case_sigstats_5/Skewness
%  Case_sigstats_5/Std
%  Case_sigstats_5/THD
%  Case_sigstats_6/ClearanceFactor
%  Case_sigstats_6/CrestFactor
%  Case_sigstats_6/ImpulseFactor
%  Case_sigstats_6/Kurtosis
%  Case_sigstats_6/Mean
%  Case_sigstats_6/PeakValue
%  Case_sigstats_6/RMS
%  Case_sigstats_6/SINAD
%  Case_sigstats_6/SNR
%  Case_sigstats_6/ShapeFactor
%  Case_sigstats_6/Skewness
%  Case_sigstats_6/Std
%  Case_sigstats_6/THD
%  Case_ps_spec/PeakAmp1
%  Case_ps_spec/PeakFreq1
%  Case_ps_spec/BandPower
%  Case_ps_1_spec/PeakAmp1
%  Case_ps_1_spec/PeakFreq1
%  Case_ps_1_spec/BandPower
%  Case_ps_2_spec/PeakAmp1
%  Case_ps_2_spec/PeakFreq1
%  Case_ps_2_spec/BandPower
%  Case_ps_3_spec/PeakAmp1
%  Case_ps_3_spec/PeakFreq1
%  Case_ps_3_spec/BandPower
%  Case_ps_4_spec/PeakAmp1
%  Case_ps_4_spec/PeakFreq1
%  Case_ps_4_spec/BandPower
%  Case_ps_5_spec/PeakAmp1
%  Case_ps_5_spec/PeakFreq1
%  Case_ps_5_spec/BandPower
%  Case_ps_6_spec/PeakAmp1
%  Case_ps_6_spec/PeakFreq1
%  Case_ps_6_spec/BandPower
%
% This function ranks computed feautres using algorithms:
%  T-Test
%  ROC
%
% Frame Policy:
%  Frame name: FRM_1
%  Frame size: 0.4 seconds
%  Frame rate: 0.4 seconds
%
% Organization of the function:
% 1. Compute signals/spectra/features
% 2. Extract computed features into a table
% 3. Rank features
%
% Modify the function to add or remove data processing, feature generation
% or ranking operations.

% Auto-generated by MATLAB on 20-Jan-2025 14:41:09

% Create output ensemble.
outputEnsemble = workspaceEnsemble(inputData,'DataVariables',"Case",'ConditionVariables',"Task1");

% Reset the ensemble to read from the beginning of the ensemble.
reset(outputEnsemble);

% Append new frame policy name to DataVariables.
outputEnsemble.DataVariables = [outputEnsemble.DataVariables;"FRM_1"];

% Set SelectedVariables to select variables to read from the ensemble.
outputEnsemble.SelectedVariables = "Case";

% Initialize a cell array to store all the results.
allMembersResult = {};

% Loop through all ensemble members to read and write data.
while hasdata(outputEnsemble)
    % Read one member.
    member = read(outputEnsemble);

    % Read signals.
    Case_full = readMemberData(member,"Case",["TIME","P1","P2","P3","P4","P5","P6","P7"]);

    % Get the frame intervals.
    lowerBound = Case_full.TIME(1);
    upperBound = Case_full.TIME(end);
    fullIntervals = frameintervals([lowerBound upperBound],0.4,0.4,'FrameUnit',"seconds");
    intervals = fullIntervals;

    % Initialize a table to store frame results.
    frames = table;

    % Loop through all frame intervals and compute results.
    for ct = 1:height(intervals)
        % Get all input variables.
        Case = Case_full(Case_full.TIME>=intervals{ct,1}&Case_full.TIME<intervals{ct,2},:);

        % Initialize a table to store results for one frame interval.
        frame = intervals(ct,:);

        %% SignalFeatures
        try
            % Compute signal features.
            inputSignal = Case.P1;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            SINAD = sinad(inputSignal);
            SNR = snr(inputSignal);
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');
            THD = thd(inputSignal);

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,SINAD,SNR,ShapeFactor,Skewness,Std,THD];

            % Store computed features in a table.
            featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
            Case_sigstats = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Store computed features in a table.
            featureValues = NaN(1,13);
            featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
            Case_sigstats = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_sigstats},'VariableNames',{'Case_sigstats'})];

        %% SignalFeatures
        try
            % Compute signal features.
            inputSignal = Case.P2;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            SINAD = sinad(inputSignal);
            SNR = snr(inputSignal);
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');
            THD = thd(inputSignal);

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,SINAD,SNR,ShapeFactor,Skewness,Std,THD];

            % Store computed features in a table.
            featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
            Case_sigstats_1 = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Store computed features in a table.
            featureValues = NaN(1,13);
            featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
            Case_sigstats_1 = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_sigstats_1},'VariableNames',{'Case_sigstats_1'})];

        %% SignalFeatures
        try
            % Compute signal features.
            inputSignal = Case.P3;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            SINAD = sinad(inputSignal);
            SNR = snr(inputSignal);
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');
            THD = thd(inputSignal);

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,SINAD,SNR,ShapeFactor,Skewness,Std,THD];

            % Store computed features in a table.
            featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
            Case_sigstats_2 = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Store computed features in a table.
            featureValues = NaN(1,13);
            featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
            Case_sigstats_2 = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_sigstats_2},'VariableNames',{'Case_sigstats_2'})];

        %% SignalFeatures
        try
            % Compute signal features.
            inputSignal = Case.P4;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            SINAD = sinad(inputSignal);
            SNR = snr(inputSignal);
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');
            THD = thd(inputSignal);

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,SINAD,SNR,ShapeFactor,Skewness,Std,THD];

            % Store computed features in a table.
            featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
            Case_sigstats_3 = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Store computed features in a table.
            featureValues = NaN(1,13);
            featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
            Case_sigstats_3 = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_sigstats_3},'VariableNames',{'Case_sigstats_3'})];

        %% SignalFeatures
        try
            % Compute signal features.
            inputSignal = Case.P5;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            SINAD = sinad(inputSignal);
            SNR = snr(inputSignal);
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');
            THD = thd(inputSignal);

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,SINAD,SNR,ShapeFactor,Skewness,Std,THD];

            % Store computed features in a table.
            featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
            Case_sigstats_4 = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Store computed features in a table.
            featureValues = NaN(1,13);
            featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
            Case_sigstats_4 = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_sigstats_4},'VariableNames',{'Case_sigstats_4'})];

        %% SignalFeatures
        try
            % Compute signal features.
            inputSignal = Case.P6;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            SINAD = sinad(inputSignal);
            SNR = snr(inputSignal);
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');
            THD = thd(inputSignal);

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,SINAD,SNR,ShapeFactor,Skewness,Std,THD];

            % Store computed features in a table.
            featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
            Case_sigstats_5 = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Store computed features in a table.
            featureValues = NaN(1,13);
            featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
            Case_sigstats_5 = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_sigstats_5},'VariableNames',{'Case_sigstats_5'})];

        %% SignalFeatures
        try
            % Compute signal features.
            inputSignal = Case.P7;
            ClearanceFactor = max(abs(inputSignal))/(mean(sqrt(abs(inputSignal)))^2);
            CrestFactor = peak2rms(inputSignal);
            ImpulseFactor = max(abs(inputSignal))/mean(abs(inputSignal));
            Kurtosis = kurtosis(inputSignal);
            Mean = mean(inputSignal,'omitnan');
            PeakValue = max(abs(inputSignal));
            RMS = rms(inputSignal,'omitnan');
            SINAD = sinad(inputSignal);
            SNR = snr(inputSignal);
            ShapeFactor = rms(inputSignal,'omitnan')/mean(abs(inputSignal),'omitnan');
            Skewness = skewness(inputSignal);
            Std = std(inputSignal,'omitnan');
            THD = thd(inputSignal);

            % Concatenate signal features.
            featureValues = [ClearanceFactor,CrestFactor,ImpulseFactor,Kurtosis,Mean,PeakValue,RMS,SINAD,SNR,ShapeFactor,Skewness,Std,THD];

            % Store computed features in a table.
            featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
            Case_sigstats_6 = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Store computed features in a table.
            featureValues = NaN(1,13);
            featureNames = {'ClearanceFactor','CrestFactor','ImpulseFactor','Kurtosis','Mean','PeakValue','RMS','SINAD','SNR','ShapeFactor','Skewness','Std','THD'};
            Case_sigstats_6 = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_sigstats_6},'VariableNames',{'Case_sigstats_6'})];

        %% PowerSpectrum
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(Case.TIME,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x_raw = Case.P1;
            if irregular
                x = resample(x_raw,tNumeric,Fs,'linear');
            else
                x = x_raw;
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,4,arOpt);

            % Compute the power spectrum.
            [ps,w] = spectrum(model);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', {'Frequency', 'SpectrumData'});
            ps.Properties.VariableUnits = {'Hz', ''};
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            Case_ps = ps;
        catch
            Case_ps = table(NaN, NaN, 'VariableNames', {'Frequency', 'SpectrumData'});
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_ps},'VariableNames',{'Case_ps'})];

        %% PowerSpectrum
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(Case.TIME,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x_raw = Case.P2;
            if irregular
                x = resample(x_raw,tNumeric,Fs,'linear');
            else
                x = x_raw;
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,4,arOpt);

            % Compute the power spectrum.
            [ps,w] = spectrum(model);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', {'Frequency', 'SpectrumData'});
            ps.Properties.VariableUnits = {'Hz', ''};
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            Case_ps_1 = ps;
        catch
            Case_ps_1 = table(NaN, NaN, 'VariableNames', {'Frequency', 'SpectrumData'});
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_ps_1},'VariableNames',{'Case_ps_1'})];

        %% PowerSpectrum
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(Case.TIME,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x_raw = Case.P3;
            if irregular
                x = resample(x_raw,tNumeric,Fs,'linear');
            else
                x = x_raw;
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,4,arOpt);

            % Compute the power spectrum.
            [ps,w] = spectrum(model);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', {'Frequency', 'SpectrumData'});
            ps.Properties.VariableUnits = {'Hz', ''};
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            Case_ps_2 = ps;
        catch
            Case_ps_2 = table(NaN, NaN, 'VariableNames', {'Frequency', 'SpectrumData'});
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_ps_2},'VariableNames',{'Case_ps_2'})];

        %% PowerSpectrum
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(Case.TIME,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x_raw = Case.P4;
            if irregular
                x = resample(x_raw,tNumeric,Fs,'linear');
            else
                x = x_raw;
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,4,arOpt);

            % Compute the power spectrum.
            [ps,w] = spectrum(model);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', {'Frequency', 'SpectrumData'});
            ps.Properties.VariableUnits = {'Hz', ''};
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            Case_ps_3 = ps;
        catch
            Case_ps_3 = table(NaN, NaN, 'VariableNames', {'Frequency', 'SpectrumData'});
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_ps_3},'VariableNames',{'Case_ps_3'})];

        %% PowerSpectrum
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(Case.TIME,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x_raw = Case.P5;
            if irregular
                x = resample(x_raw,tNumeric,Fs,'linear');
            else
                x = x_raw;
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,4,arOpt);

            % Compute the power spectrum.
            [ps,w] = spectrum(model);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', {'Frequency', 'SpectrumData'});
            ps.Properties.VariableUnits = {'Hz', ''};
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            Case_ps_4 = ps;
        catch
            Case_ps_4 = table(NaN, NaN, 'VariableNames', {'Frequency', 'SpectrumData'});
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_ps_4},'VariableNames',{'Case_ps_4'})];

        %% PowerSpectrum
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(Case.TIME,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x_raw = Case.P6;
            if irregular
                x = resample(x_raw,tNumeric,Fs,'linear');
            else
                x = x_raw;
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,4,arOpt);

            % Compute the power spectrum.
            [ps,w] = spectrum(model);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', {'Frequency', 'SpectrumData'});
            ps.Properties.VariableUnits = {'Hz', ''};
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            Case_ps_5 = ps;
        catch
            Case_ps_5 = table(NaN, NaN, 'VariableNames', {'Frequency', 'SpectrumData'});
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_ps_5},'VariableNames',{'Case_ps_5'})];

        %% PowerSpectrum
        try
            % Get units to use in computed spectrum.
            tuReal = "seconds";
            tuTime = tuReal;

            % Compute effective sampling rate.
            tNumeric = time2num(Case.TIME,tuReal);
            [Fs,irregular] = effectivefs(tNumeric);
            Ts = 1/Fs;

            % Resample non-uniform signals.
            x_raw = Case.P7;
            if irregular
                x = resample(x_raw,tNumeric,Fs,'linear');
            else
                x = x_raw;
            end

            % Compute the autoregressive model.
            data = iddata(x,[],Ts,'TimeUnit',tuTime,'OutputName','SpectrumData');
            arOpt = arOptions('Approach','fb','Window','now','EstimateCovariance',false);
            model = ar(data,4,arOpt);

            % Compute the power spectrum.
            [ps,w] = spectrum(model);
            ps = reshape(ps, numel(ps), 1);

            % Convert frequency unit.
            factor = funitconv('rad/TimeUnit', 'Hz', 'seconds');
            w = factor*w;
            Fs = 2*pi*factor*Fs;

            % Remove frequencies above Nyquist frequency.
            I = w<=(Fs/2+1e4*eps);
            w = w(I);
            ps = ps(I);

            % Configure the computed spectrum.
            ps = table(w, ps, 'VariableNames', {'Frequency', 'SpectrumData'});
            ps.Properties.VariableUnits = {'Hz', ''};
            ps = addprop(ps, {'SampleFrequency'}, {'table'});
            ps.Properties.CustomProperties.SampleFrequency = Fs;
            Case_ps_6 = ps;
        catch
            Case_ps_6 = table(NaN, NaN, 'VariableNames', {'Frequency', 'SpectrumData'});
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_ps_6},'VariableNames',{'Case_ps_6'})];

        %% SpectrumFeatures
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = Case_ps.SpectrumData;
            w = Case_ps.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*0) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
            peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakFreq1 = peakFreq(1);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakFreq1,BandPower];

            % Store computed features in a table.
            featureNames = {'PeakAmp1','PeakFreq1','BandPower'};
            Case_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Store computed features in a table.
            featureValues = NaN(1,3);
            featureNames = {'PeakAmp1','PeakFreq1','BandPower'};
            Case_ps_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_ps_spec},'VariableNames',{'Case_ps_spec'})];

        %% SpectrumFeatures
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = Case_ps_1.SpectrumData;
            w = Case_ps_1.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*0) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
            peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakFreq1 = peakFreq(1);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakFreq1,BandPower];

            % Store computed features in a table.
            featureNames = {'PeakAmp1','PeakFreq1','BandPower'};
            Case_ps_1_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Store computed features in a table.
            featureValues = NaN(1,3);
            featureNames = {'PeakAmp1','PeakFreq1','BandPower'};
            Case_ps_1_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_ps_1_spec},'VariableNames',{'Case_ps_1_spec'})];

        %% SpectrumFeatures
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = Case_ps_2.SpectrumData;
            w = Case_ps_2.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*0) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
            peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakFreq1 = peakFreq(1);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakFreq1,BandPower];

            % Store computed features in a table.
            featureNames = {'PeakAmp1','PeakFreq1','BandPower'};
            Case_ps_2_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Store computed features in a table.
            featureValues = NaN(1,3);
            featureNames = {'PeakAmp1','PeakFreq1','BandPower'};
            Case_ps_2_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_ps_2_spec},'VariableNames',{'Case_ps_2_spec'})];

        %% SpectrumFeatures
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = Case_ps_3.SpectrumData;
            w = Case_ps_3.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*0) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
            peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakFreq1 = peakFreq(1);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakFreq1,BandPower];

            % Store computed features in a table.
            featureNames = {'PeakAmp1','PeakFreq1','BandPower'};
            Case_ps_3_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Store computed features in a table.
            featureValues = NaN(1,3);
            featureNames = {'PeakAmp1','PeakFreq1','BandPower'};
            Case_ps_3_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_ps_3_spec},'VariableNames',{'Case_ps_3_spec'})];

        %% SpectrumFeatures
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = Case_ps_4.SpectrumData;
            w = Case_ps_4.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*0) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
            peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakFreq1 = peakFreq(1);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakFreq1,BandPower];

            % Store computed features in a table.
            featureNames = {'PeakAmp1','PeakFreq1','BandPower'};
            Case_ps_4_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Store computed features in a table.
            featureValues = NaN(1,3);
            featureNames = {'PeakAmp1','PeakFreq1','BandPower'};
            Case_ps_4_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_ps_4_spec},'VariableNames',{'Case_ps_4_spec'})];

        %% SpectrumFeatures
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = Case_ps_5.SpectrumData;
            w = Case_ps_5.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*0) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
            peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakFreq1 = peakFreq(1);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakFreq1,BandPower];

            % Store computed features in a table.
            featureNames = {'PeakAmp1','PeakFreq1','BandPower'};
            Case_ps_5_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Store computed features in a table.
            featureValues = NaN(1,3);
            featureNames = {'PeakAmp1','PeakFreq1','BandPower'};
            Case_ps_5_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_ps_5_spec},'VariableNames',{'Case_ps_5_spec'})];

        %% SpectrumFeatures
        try
            % Compute spectral features.
            % Get frequency unit conversion factor.
            factor = funitconv('Hz', 'rad/TimeUnit', 'seconds');
            ps = Case_ps_6.SpectrumData;
            w = Case_ps_6.Frequency;
            w = factor*w;
            mask_1 = (w>=factor*0) & (w<=factor*10);
            ps = ps(mask_1);
            w = w(mask_1);

            % Compute spectral peaks.
            [peakAmp,peakFreq] = findpeaks(ps,w/factor,'MinPeakHeight',-Inf, ...
                'MinPeakProminence',0,'MinPeakDistance',0.001,'SortStr','descend','NPeaks',1);
            peakAmp = [peakAmp(:); NaN(1-numel(peakAmp),1)];
            peakFreq = [peakFreq(:); NaN(1-numel(peakFreq),1)];

            % Extract individual feature values.
            PeakAmp1 = peakAmp(1);
            PeakFreq1 = peakFreq(1);
            BandPower = trapz(w/factor,ps);

            % Concatenate signal features.
            featureValues = [PeakAmp1,PeakFreq1,BandPower];

            % Store computed features in a table.
            featureNames = {'PeakAmp1','PeakFreq1','BandPower'};
            Case_ps_6_spec = array2table(featureValues,'VariableNames',featureNames);
        catch
            % Store computed features in a table.
            featureValues = NaN(1,3);
            featureNames = {'PeakAmp1','PeakFreq1','BandPower'};
            Case_ps_6_spec = array2table(featureValues,'VariableNames',featureNames);
        end

        % Append computed results to the frame table.
        frame = [frame, ...
            table({Case_ps_6_spec},'VariableNames',{'Case_ps_6_spec'})];

        %% Concatenate frames.
        frames = [frames;frame]; %#ok<*AGROW>
    end
    % Append all member results to the cell array.
    memberResult = table({frames},'VariableNames',"FRM_1");
    allMembersResult = [allMembersResult; {memberResult}]; %#ok<AGROW>
end

% Write the results for all members to the ensemble.
writeToMembers(outputEnsemble,allMembersResult)

% Gather all features into a table.
selectedFeatureNames = ["FRM_1/Case_sigstats/ClearanceFactor","FRM_1/Case_sigstats/CrestFactor","FRM_1/Case_sigstats/ImpulseFactor","FRM_1/Case_sigstats/Kurtosis","FRM_1/Case_sigstats/Mean","FRM_1/Case_sigstats/PeakValue","FRM_1/Case_sigstats/RMS","FRM_1/Case_sigstats/SINAD","FRM_1/Case_sigstats/SNR","FRM_1/Case_sigstats/ShapeFactor","FRM_1/Case_sigstats/Skewness","FRM_1/Case_sigstats/Std","FRM_1/Case_sigstats/THD","FRM_1/Case_sigstats_1/ClearanceFactor","FRM_1/Case_sigstats_1/CrestFactor","FRM_1/Case_sigstats_1/ImpulseFactor","FRM_1/Case_sigstats_1/Kurtosis","FRM_1/Case_sigstats_1/Mean","FRM_1/Case_sigstats_1/PeakValue","FRM_1/Case_sigstats_1/RMS","FRM_1/Case_sigstats_1/SINAD","FRM_1/Case_sigstats_1/SNR","FRM_1/Case_sigstats_1/ShapeFactor","FRM_1/Case_sigstats_1/Skewness","FRM_1/Case_sigstats_1/Std","FRM_1/Case_sigstats_1/THD","FRM_1/Case_sigstats_2/ClearanceFactor","FRM_1/Case_sigstats_2/CrestFactor","FRM_1/Case_sigstats_2/ImpulseFactor","FRM_1/Case_sigstats_2/Kurtosis","FRM_1/Case_sigstats_2/Mean","FRM_1/Case_sigstats_2/PeakValue","FRM_1/Case_sigstats_2/RMS","FRM_1/Case_sigstats_2/SINAD","FRM_1/Case_sigstats_2/SNR","FRM_1/Case_sigstats_2/ShapeFactor","FRM_1/Case_sigstats_2/Skewness","FRM_1/Case_sigstats_2/Std","FRM_1/Case_sigstats_2/THD","FRM_1/Case_sigstats_3/ClearanceFactor","FRM_1/Case_sigstats_3/CrestFactor","FRM_1/Case_sigstats_3/ImpulseFactor","FRM_1/Case_sigstats_3/Kurtosis","FRM_1/Case_sigstats_3/Mean","FRM_1/Case_sigstats_3/PeakValue","FRM_1/Case_sigstats_3/RMS","FRM_1/Case_sigstats_3/SINAD","FRM_1/Case_sigstats_3/SNR","FRM_1/Case_sigstats_3/ShapeFactor","FRM_1/Case_sigstats_3/Skewness","FRM_1/Case_sigstats_3/Std","FRM_1/Case_sigstats_3/THD","FRM_1/Case_sigstats_4/ClearanceFactor","FRM_1/Case_sigstats_4/CrestFactor","FRM_1/Case_sigstats_4/ImpulseFactor","FRM_1/Case_sigstats_4/Kurtosis","FRM_1/Case_sigstats_4/Mean","FRM_1/Case_sigstats_4/PeakValue","FRM_1/Case_sigstats_4/RMS","FRM_1/Case_sigstats_4/SINAD","FRM_1/Case_sigstats_4/SNR","FRM_1/Case_sigstats_4/ShapeFactor","FRM_1/Case_sigstats_4/Skewness","FRM_1/Case_sigstats_4/Std","FRM_1/Case_sigstats_4/THD","FRM_1/Case_sigstats_5/ClearanceFactor","FRM_1/Case_sigstats_5/CrestFactor","FRM_1/Case_sigstats_5/ImpulseFactor","FRM_1/Case_sigstats_5/Kurtosis","FRM_1/Case_sigstats_5/Mean","FRM_1/Case_sigstats_5/PeakValue","FRM_1/Case_sigstats_5/RMS","FRM_1/Case_sigstats_5/SINAD","FRM_1/Case_sigstats_5/SNR","FRM_1/Case_sigstats_5/ShapeFactor","FRM_1/Case_sigstats_5/Skewness","FRM_1/Case_sigstats_5/Std","FRM_1/Case_sigstats_5/THD","FRM_1/Case_sigstats_6/ClearanceFactor","FRM_1/Case_sigstats_6/CrestFactor","FRM_1/Case_sigstats_6/ImpulseFactor","FRM_1/Case_sigstats_6/Kurtosis","FRM_1/Case_sigstats_6/Mean","FRM_1/Case_sigstats_6/PeakValue","FRM_1/Case_sigstats_6/RMS","FRM_1/Case_sigstats_6/SINAD","FRM_1/Case_sigstats_6/SNR","FRM_1/Case_sigstats_6/ShapeFactor","FRM_1/Case_sigstats_6/Skewness","FRM_1/Case_sigstats_6/Std","FRM_1/Case_sigstats_6/THD","FRM_1/Case_ps_spec/PeakAmp1","FRM_1/Case_ps_spec/PeakFreq1","FRM_1/Case_ps_spec/BandPower","FRM_1/Case_ps_1_spec/PeakAmp1","FRM_1/Case_ps_1_spec/PeakFreq1","FRM_1/Case_ps_1_spec/BandPower","FRM_1/Case_ps_2_spec/PeakAmp1","FRM_1/Case_ps_2_spec/PeakFreq1","FRM_1/Case_ps_2_spec/BandPower","FRM_1/Case_ps_3_spec/PeakAmp1","FRM_1/Case_ps_3_spec/PeakFreq1","FRM_1/Case_ps_3_spec/BandPower","FRM_1/Case_ps_4_spec/PeakAmp1","FRM_1/Case_ps_4_spec/PeakFreq1","FRM_1/Case_ps_4_spec/BandPower","FRM_1/Case_ps_5_spec/PeakAmp1","FRM_1/Case_ps_5_spec/PeakFreq1","FRM_1/Case_ps_5_spec/BandPower","FRM_1/Case_ps_6_spec/PeakAmp1","FRM_1/Case_ps_6_spec/PeakFreq1","FRM_1/Case_ps_6_spec/BandPower"];
featureTable = readFeatureTable(outputEnsemble,"FRM_1",'Features',selectedFeatureNames,'ConditionVariables',outputEnsemble.ConditionVariables,'IncludeMemberID',true);

% Feature ranking for FeatureTable1

% Get selected features and labels for classification ranking.
selectedFeatureValues = featureTable{:,selectedFeatureNames};
label = featureTable{:,"Task1"};

% Convert label to numeric values.
if iscategorical(label)
    label = string(label);
end
group = grp2idx(label);

% Initialize an empty matrix to store ranking scores.
score = zeros(numel(selectedFeatureNames),0);

% Initialize a string array to store ranking method names.
methodList = strings(0);

%% T-Test
% Normalize features using minmax.
fNorm = (selectedFeatureValues-min(selectedFeatureValues,[],1))./(max(selectedFeatureValues,[],1)-min(selectedFeatureValues,[],1));

% Compute ranking score using T-Test.
mask = (group==1);
[~,~,~,stats] = ttest2(fNorm(mask,:),fNorm(~mask,:),'Vartype','unequal');
z = abs(stats.tstat');

% Append new score and method name.
score = [score,z];
methodList = [methodList,"T-Test"];

%% ROC
% Normalize features using minmax.
fNorm = (selectedFeatureValues-min(selectedFeatureValues,[],1))./(max(selectedFeatureValues,[],1)-min(selectedFeatureValues,[],1));

% Compute ranking score using receiver operating characteristic (ROC).
mask = (group==1);
numFeatures = size(fNorm,2);
z = zeros(numFeatures,1);
for k = 1:numFeatures
    % Create generalized linear regression model.
    mdl = fitglm(fNorm(:,k),mask,'Distribution','binomial','Link','logit');
    scores= mdl.Fitted.Probability;
    % Compute a receiver operating characteristic curve.
    [~,~,~,AUC] = perfcurve(mask,scores,1);
    if ~isempty(AUC)
        z(k) = abs(AUC-0.5);
    end
end

% Append new score and method name.
score = [score,z];
methodList = [methodList,"ROC"];


%% Create ranking result table.
featureColumn = table(selectedFeatureNames(:),'VariableNames',{'Features'});
ranking = [featureColumn array2table(score,'VariableNames',methodList)];
ranking = sortrows(ranking,'T-Test','descend');

% Set SelectedVariables to select variables to read from the ensemble.
outputEnsemble.SelectedVariables = unique([outputEnsemble.DataVariables;outputEnsemble.ConditionVariables;outputEnsemble.IndependentVariables],'stable');

% Gather results into a table.
if nargout > 1
    outputTable = readall(outputEnsemble);
end
end
